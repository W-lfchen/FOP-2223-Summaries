# Referenzen und Objekte bei Methodenaufrufen
- Wenn ein Parameter einer Methode von einem Referenztyp ist, dann verweist der formale Parameter innerhalb der Methode auf dasselbe Objekt wie der aktuale Parameter außerhalb der Methode.
- `return` schreibt Rückgabewert in ein bestimmtes Register
# Verborgene Informationen
- Jedes Objekt einer Klasse enthält Verweis auf klassenspezifischen anonymes Objekt
- Anonymes Objekt enthält Informationen zur Klasse und ihren Attributen/Methoden, außerdem die Methodentabelle
## Methodentabelle
- hat festen, in allen Klassen identischen Offset in den Informationen zur Klasse
- Bei Vererbung werden geerbte Methoden hinten "drangehängt"
- Beim Überschreiben von Methoden im Rahmen von Vererbung gibt es nur Verweis auf neue Implementation
- -> Dynamischer Typ ist verantwortlich dafür, was Methodenaufruf macht
# Klassenmethoden
- Schlüsselwort `static`, dürfen nicht auf Objektattribute/Objektmethoden zugreifen
- Auf Klassenattribute/Klassenmethoden darf zugegriffen werden
- `X.m()` ist Aufruf von Methode m der Klasse X, auch über Objekte möglich
```
for(Weekday day : Weekday.values()) // Weekday ist Enum, values() ist Klassenmethode, die ein Array der Enum-Objekte liefert
                                    // vereinfachte for-Schleife wird hier verwendet
  System.out.println(day.name());   // name() liefert Name des Objektes aus der Enum-Definition als String
``` 
# Variable Parameterzahl
- Als letztes formalen Parameter kann man z.B. `double... a` verwenden, hier ist Typ double und Name a
- a ist dann ein Array
- Bei Verwendung der Methode kann an der Stelle von a ein Array überreicht werden
- Alternativ eine beliebige Anzahl (auch 0!) an double-Werten, wie bei normalen Parametern durch Kommata getrennt
- Wenn letzteres der Fall ist, werden die Werte mit aufsteigenden Indizes in Array getan
# Struktur von Methoden
- Head (Kopf): Alles vor den eigentlichen Anweisungen
- Body (Rumpf): Die Anweisungen in geschweiften Klammern
## Kopf einer Methode
- Einstiegsmethode (muss exakt eingehalten werden): `public static void main(String[] args)`
- `main  ist Name/Identifier
- `void` steht hier anstelle eines Rückgabetyps, muss immer unmittelbar vor Namen stehen
- `public static` sind Modifier, stehen vor Rückgabetyp/`void`, ändern nichts an Methode, nur deren Verwendung
- `(String[] args)` ist hier Parameterliste, unmittelbar nach Name; Parameter sind durch Kommata getrennt; Parameter sind Typ gefolgt von Name
- bei verwenden der Einstiegsmethode ist `args` Kommandozeilenparameterliste
- unmittelbar nach der Parameterliste kann noch `throws`-Klausel folgen, z.B. `throws YException, XException`
- main darf keine throws-Klausel haben
### Zusammenfassung der Bestandteile
- Name
- Ungeordnete Menge der Modifier -> Reihenfolge egal
- Rückgabetyp
- Parameterliste: geordnete Sequenz der Typen der Parameter, Namen sind dem Nutzer der Methode in erster Linie egal
- Ungeordnete Menge der Exceptions
### Javadoc für Methodenköpfe
```
/**
* @param x the dividend                   // Beschreiben, was die Parameter tun
* @param y the divisor, must not be zero  // Vorbedingungen angeben
* @return x integer-divided by y          // was zurückgegeben wird (entfällt bei void natürlich)
*/
public int quotient ( int x, int y ) {
  return x / y;
}
```
# Signatur und Überschreiben/Überladen von Methoden
- Eine Klasse kann keine zwei Methoden gleicher Signatur haben
- Beim Überschreiben geht überschriebene Methode verloren
- Beim Überladen müssen sich Signaturen unterscheiden
## Signatur einer Methode
- Besteht aus Name und Parameterliste als geordnete Sequenz der Typen der Parameter
## Überschreiben einer Methode
- Implementation in Basisklasse ist überschriebene Methode
- Implementation in abgeleiteter Klasse ist überschreibenede Methode
- Signatur muss bei beiden Methoden identische sein
- Zugriffsrecht darf nur erweitert werden: private -> ε -> protected -> public
- Bei primitven Datentypen: Rückgabetyp gleich; Bei Referenztypen durch Subtyp ersetzbar
- Exceptionklassen durch abgeleitete Exceptionklassen ersetzbar
### Klassenmethoden
- werden an Subtypen vererbt
- Im Subtyp kann Klassenmethode mit identischer Signatur definiert werden, Implementationsauswahl richtet sich nach statischem Typ
## Überladen von Methoden
- Zwei oder mehr Methoden einer Klasse haben selben Namen, z.B. `println()` von PrintStream
- Bei Überladung müssen die Sequenzen der Parametertypen unterschiedlich sein
```
public class X {
  public void m ( int i, double d ) {...} // Ein Beispiel für korrekte Überladung:
  public void m ( double d, int i ) {...} // Signatur ist anders
}
X a = new X(); a.m(321, 123);             // geht nicht durch Compiler, weil unklar ist, welche Methode aufgerufen wird
```
# Konstruktoren und Static Initialiser
## Konstruktor
- kein Rückgabetyp, auch nicht void
- Name des Konstruktors ist gleich dem Namen der Klasse
- Falls kein Konstruktor in Klasse definiert, wird automatisch Default Constructor hinzugefügt: leere Parameterliste&Body
- Unmittelbare Basisklasse muss ebenfalls einen Konstruktor mit leerer Parameterliste haben, dieser wird vom Default Construcotr aufgerufen
- Konstruktoren werden nicht vererbt
## Static Initialiser
```
public final static int I;  //Klassenkonstante
static{                    // nur static, nichts anderes
  I = ...;                 // Konstante wird zu Beginn der Programmausführung zugewiesen
}
```
# Finale Methoden
- Schlüsselwort final bei Methoden sorgt dafür, dass Methode nicht überschrieben werden darf
# Methodenrumpf
## Anweisungen: Variablen- und Konstantendefinitionen
```
int m;                                    // Definition einer Variable von Typ int
int n = 1;                                // Definition mit Initialisierung
final int r = 2;                           // Konstante mit Initialisierung
String str1;                              // Gleiches gilt auch für Referenztypen
String str2 = new String(“Hello World“);  // String Konstruktor zur Initialisierung
double[] a;                               // Definition einer Variable, Typ "Array von double"
double[] b = new double [10];             // Arrayvariable mit Initialisierung
int m = 1, n, k = 2;                      // Alle von Typ int, m hat Wert 1, n ist nicht initialisiert, k hat Wert 2
```
### Variablendefinitionen ohne explizite Initialisierung
- (lokale) Variable: undefinierter Wert, Zugriff während undefiniertem Wert geht nicht durch Compiler
- Konstante: nicht möglich
- Attribute und Arraykomponenten: implizit auf Nullwert gesetzt
#### Nullwert
- Zahlentypen: 0
- char: '\u0000'
- boolean: false
- Referenztypen: null
## Anweisungen: Schlüsselwörter this und super
```
public class X{
  public int n;
  public void setI(int n){
    this.n = n;             // this.n ist Attribut n
  }
  public X(int n){
    this.n = n;             // n ist Parameter n
  }
  public X(){
    this(42);               // Konstruktoraufruf
  }
  public void m1(){...}     // Methode
}
public class Y extends x{
  public double n;          // trotz Namensgleichheit zwei verschiedene Attribute, dürfen sogar von selbem Typ sein
  public void m1(){...}     // Überschreiben von m1
  public void m2(){
    n = 3.14;               // Zugriff auf Attribut von Y
    super.n = 123;          // Wenn Zugriffsrecht stimmt, wird hier auf Attribut n von X zugegriffen
    m1();                   // Überschreibende Methode
    super.m1();             // Überschriebene Methode
  }
  public Y(){
    super(123);             // Aufruf des Konstruktors der Basisklasse muss erste Anweisung sein
    n = 1;
  }
}
```
## Ausdrücke: Rechtsausdrücke (rvalues) und Linksausdrücke (lvalues)
### Rechtsausdrücke
- Haben Typ und Wert

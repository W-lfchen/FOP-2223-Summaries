# Referenzen und Objekte bei Methodenaufrufen
- Wenn ein Parameter einer Methode von einem Referenztyp ist, dann verweist der formale Parameter innerhalb der Methode auf dasselbe Objekt wie der aktuale Parameter außerhalb der Methode.
- `return` schreibt Rückgabewert in ein bestimmtes Register
# Verborgene Informationen
- Jedes Objekt einer Klasse enthält Verweis auf klassenspezifischen anonymes Objekt
- Anonymes Objekt enthält Informationen zur Klasse und ihren Attributen/Methoden, außerdem die Methodentabelle
## Methodentabelle
- hat festen, in allen Klassen identischen Offset in den Informationen zur Klasse
- Bei Vererbung werden geerbte Methoden hinten "drangehängt"
- Beim Überschreiben von Methoden im Rahmen von Vererbung gibt es nur Verweis auf neue Implementation
- -> Dynamischer Typ ist verantwortlich dafür, was Methodenaufruf macht
# Klassenmethoden
- Schlüsselwort `static`, dürfen nicht auf Objektattribute/Objektmethoden zugreifen
- Auf Klassenattribute/Klassenmethoden darf zugegriffen werden
- `X.m()` ist Aufruf von Methode m der Klasse X, auch über Objekte möglich
```
for(Weekday day : Weekday.values()) // Weekday ist Enum, values() ist Klassenmethode, die ein Array der Enum-Objekte liefert
                                    // vereinfachte for-Schleife wird hier verwendet
  System.out.println(day.name());   // name() liefert Name des Objektes aus der Enum-Definition als String
``` 
# Variable Parameterzahl
- Als letztes formalen Parameter kann man z.B. `double... a` verwenden, hier ist Typ double und Name a
- a ist dann ein Array
- Bei Verwendung der Methode kann an der Stelle von a ein Array überreicht werden
- Alternativ eine beliebige Anzahl (auch 0!) an double-Werten, wie bei normalen Parametern durch Kommata getrennt
- Wenn letzteres der Fall ist, werden die Werte mit aufsteigenden Indizes in Array getan
# Struktur von Methoden
- Head (Kopf): Alles vor den eigentlichen Anweisungen
- Body (Rumpf): Die Anweisungen in geschweiften Klammern
## Kopf einer Methode
- Einstiegsmethode (muss exakt eingehalten werden): `public static void main(String[] args)`
- `main  ist Name/Identifier
- `void` steht hier anstelle eines Rückgabetyps, muss immer unmittelbar vor Namen stehen
- `public static` sind Modifier, stehen vor Rückgabetyp/`void`, ändern nichts an Methode, nur deren Verwendung
- `(String[] args)` ist hier Parameterliste, unmittelbar nach Name; Parameter sind durch Kommata getrennt; Parameter sind Typ gefolgt von Name
- bei verwenden der Einstiegsmethode ist `args` Kommandozeilenparameterliste
- unmittelbar nach der Parameterliste kann noch `throws`-Klausel folgen, z.B. `throws YException, XException`
- main darf keine throws-Klausel haben
### Zusammenfassung der Bestandteile
- Name
- Ungeordnete Menge der Modifier -> Reihenfolge egal
- Rückgabetyp
- Parameterliste: geordnete Sequenz der Typen der Parameter, Namen sind dem Nutzer der Methode in erster Linie egal
- Ungeordnete Menge der Exceptions
### Javadoc für Methodenköpfe
```
/**
* @param x the dividend                   // Beschreiben, was die Parameter tun
* @param y the divisor, must not be zero  // Vorbedingungen angeben
* @return x integer-divided by y          // was zurückgegeben wird (entfällt bei void natürlich)
*/
public int quotient ( int x, int y ) {
  return x / y;
}
```
# Signatur und Überschreiben/Überladen von Methoden
- Eine Klasse kann keine zwei Methoden gleicher Signatur haben
- Beim Überschreiben geht überschriebene Methode verloren
- Beim Überladen müssen sich Signaturen unterscheiden
## Signatur einer Methode
- Besteht aus Name und Parameterliste als geordnete Sequenz der Typen der Parameter
